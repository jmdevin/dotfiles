scriptencoding utf-8

" TODOs

    " TODO: set diffopt

    " TODO: Change ale and vim-lsp to have highlights on, but set those highlights
    " to none by default. Have easy way to switch them on/off. Maybe have ale
    " display vim-lsp highlights?

    " TODO: does fedora always load a file to the last opened position? And if
    " so, why does this not happen in ubuntu? (This is currently being set by
    " an autocmd in ubuntu)

    " TODO: move alt-key mappings to mappings section of file

    " TODO: look at feasibility of creating indentline plugin replacement
    " using text-properties and popup windows. Text can't be added from what
    " it looks like, so it may look more like that other indent coloring
    " plugin which had colorcolumns or something.

    " TODO: look into using the 'undofile'/'undodir' feature. Maybe a
    " gitignored directory under .vim?

    " TODO: add a command to turn on and off 'help navigation keys', ie remap
    " d, u, f, b, e, and y to their <C- > counterparts

" Source defaults, do `runtime` for vim's standard included plugins
    unlet! skip_defaults_vim
    runtime defaults.vim
    silent! unmap Q
    silent! iunmap <C-U>

    filetype plugin indent on
    syntax on
    set background=dark

    runtime ftplugin/man.vim
    packadd! matchit
    packadd! cfilter

" Alt keys and cursor settings. These need work
    " if system('env') =~? 'gnome_terminal_service'
    "     let s:key='a'
    "     while s:key <=? 'z'
    "         execute 'set <M-' . toupper(s:key) . '>=' . s:key
    "         let s:key = nr2char(1 + char2nr(s:key))
    "     endwhile

        " execute ':set <M-Right>=[1;3C'
        " execute ':set <M-Left>=[1;3D'
        " execute ':set <M-Up>=[1;3A'
        " execute ':set <M-Down>=[1;3B'
    " endif

    " This      Means this
    " &t_SI     Insert mode
    " &t_SR     Replace mode
    " &t_EI     Normal mode

    "  1 -> blinking block
    "  2 -> solid block 
    "  3 -> blinking underscore
    "  4 -> solid underscore
    "  5 -> blinking vertical bar
    "  6 -> solid vertical bar

    if $TERM_PROGRAM =~? 'Apple_Terminal'
        let &t_SI = "\e[5 q"
        let &t_SR = "\e[3 q"
        let &t_EI = "\e[1 q"
    elseif $TERM =~? 'xterm' && !exists('$TMUX')
        let &t_SI = "\<Esc>[5 q"
        let &t_SR = "\<Esc>[3 q"
        let &t_EI = "\<Esc>[1 q"
    elseif $TERM =~? 'xterm\|tmux' && exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>[5 q\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>[3 q\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>[1 q\<Esc>\\"
    elseif $TERM_PROGRAM =~? 'iTerm\|xterm' && !exists('$TMUX')
        let &t_SI = "\<Esc>]50;CursorShape=1\x7"
        let &t_SR = "\<Esc>]50;CursorShape=2\x7"
        let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    elseif $TERM_PROGRAM =~? 'iTerm\|xterm' && exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    elseif exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    else
        let &t_SI = "\<Esc>]50;CursorShape=1\x7"
        let &t_SR = "\<Esc>]50;CursorShape=2\x7"
        let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    endif

" Add plugins
    call plug#begin('~/.vim/plugged')
        " possible vim-plug replacements
            " Plug 'k-takata/minpac'
        " vim
            Plug 'vim/killersheep'
        " junegunn
            Plug 'junegunn/vim-easy-align'
            " Plug 'junegunn/gv.vim'
            " Plug 'junegunn/vim-peekaboo'
            Plug 'junegunn/vim-plug'
            " Plug 'junegunn/vim-slash'
        " romainl
            Plug 'romainl/vim-cool'
            " Plug 'romainl/vim-devdocs'
            " Plug 'romainl/vim-qf'
            " Plug 'romainl/vim-qlist'
            " Plug 'romainl/vim-quicklist'
            " Plug 'romainl/vim-tinyMRU'
        " tpope
            " Plug 'tpope/vim-abolish'
            " Plug 'tpope/vim-apathy'
            " Plug 'tpope/vim-capslock'
            " Plug 'tpope/vim-characterize'
            " Plug 'tpope/vim-classpath'
            Plug 'tpope/vim-commentary'
            " Plug 'tpope/vim-endwise'
            " Plug 'tpope/vim-flagship'
            if executable('git')
                Plug 'tpope/vim-fugitive'
            endif
            " Plug 'tpope/vim-git'
            " Plug 'tpope/vim-jdaddy'
            " Plug 'tpope/vim-obsession'
            " Plug 'tpope/vim-projectionist'
            Plug 'tpope/vim-repeat'
            " Plug 'tpope/vim-rhubarb'
            " Plug 'tpope/vim-rsi'
            " Plug 'tpope/vim-scriptease'
            " Plug 'tpope/vim-sensible
            " Plug 'tpope/vim-sexp-mappings-for-regular-people'
            " Plug 'tpope/vim-sleuth'
            Plug 'tpope/vim-surround'
            " Plug 'tpope/vim-tbone'
            Plug 'tpope/vim-unimpaired'
            Plug 'tpope/vim-vinegar'
        " Appearance
            " Plug 'gko/vim-coloresque'
            " Plug 'chrisbra/vim-colorizer'
            " TODO: Plug 'wellle/context.vim'
            " Plug 'octol/vim-cpp-enhanced-highlight'
            Plug 'bfrg/vim-cpp-modern'
            " Plug 'airblade/vim-gitgutter'
            " Plug 'machakann/vim-highlightedyank'
            Plug 'yggdroot/indentline'
            " Plug 'Yilin-Yang/vim-markbar'
            " Plug 'severin-lemaignan/vim-minimap'
            " TODO: Plug 'skywind3000/vim-quickui'
            " Plug 'jaxbot/semantic-highlight.vim'
            " Plug 'mpjuers/showcontext'
            " Plug 'kshenoy/vim-signature'
            " Plug 'mhinz/vim-signify'
            " Plug 'majutsushi/tagbar'
            " Plug 'liuchengxu/vista.vim'
            " Plug 'emilyst/vim-xray'
        " Editing
            " Plug 'jiangmiao/auto-pairs'
            " Plug 'editorconfig/editorconfig-vim'
            " Plug 'haya14busa/incsearch.vim'
            " Plug 'andymass/vim-matchup'
            " Plug 'osyo-manga/vim-over'
            " Plug 'AndrewRadev/splitjoin.vim'
            " Plug 'svermeulen/vim-subversive'
            " Plug 'wellle/targets.vim'
            " Plug 'tomtom/tcomment_vim'
            " Plug 'markonm/traces.vim'
        " Linting/completion
            Plug 'dense-analysis/ale'
            " if has('python') || has('python3')
                " Plug 'davidhalter/jedi-vim'
            " endif
            " Plug 'natebosch/vim-lsc'
            " Plug 'natebosch/vim-lsc-dart'
            " Plug 'prabirshrestha/vim-lsp'
        " Language/framework/filetype
            " Plug 'cohama/agit.vim'
            Plug 'dart-lang/dart-vim-plugin'
            " Plug 'kkoomen/vim-doge'
            if executable('flutter')
                Plug 'thosakwe/vim-flutter'
            endif
            " Plug zivyangll/git-blame.vim
            " Plug 'rhysd/git-messenger.vim'
            " Plug 'idanarye/vim-merginal'
            " Plug 'vim-pandoc/vim-pandoc'
            " Plug 'sheerun/vim-polyglot'
            " Plug 'python-mode/python-mode'
            Plug 'Vimjas/vim-python-pep8-indent'
            " Plug 'jeetsukumaran/vim-pythonsense'
            Plug 'vim-python/python-syntax'
            Plug 'tmux-plugins/vim-tmux'
            " Plug 'jreybert/vimagit'
            " Plug 'jmcantrell/vim-virtualenv'
        " Other
            " Plug 'haya14busa/vim-asterisk'
            " Plug 'skywind3000/asyncrun.vim'
            " Plug 'chrisbra/vim-autoread'
            " Plug 'jlanzarotta/bufexplorer'
            " Plug 'metakirby5/codi.vim'
            " Plug 'chrisbra/vim-diff-enhanced'
            " Plug 'justinmk/vim-dirvish'
            " Plug 'chrisbra/DynamicSigns'
            " Plug 'xolox/vim-easytags'
            " Plug 'tweekmonster/helpful.vim'
            Plug 'marczych/vim-lose'
            " Plug 'bfrg/vim-qf-preview'
            " Plug 'ryvnf/readline.vim'
            " Plug 'chrisbra/Recover.vim'
            " Plug 'guns/vim-sexp'
            " Plug 'janko/vim-test'
            " Plug 'mbbill/undotree'
            " Plug 'chrisbra/unicode.vim'
            " Plug 'puremourning/vimspector'
        " Vim extension
            " TODO: Plug 'kizza/actionmenu.nvim'
            " Plug 'prabirshrestha/async.vim'
            " Plug 'prabirshrestha/asyncomplete.vim'
            " Plug 'prabirshrestha/asyncomplete-file.vim'
            " TODO: Plug 'prabirshrestha/quickpick.vim'
            " TODO: Plug 'vim-jp/vital.vim'
        " Colorschemes
            " Actually might use
            Plug 'romainl/Apprentice'
            Plug 'sainnhe/vim-color-forest-night'
            Plug 'nanotech/jellybeans.vim'
            Plug 'aonemd/kuroi.vim'
            Plug 'jonathanfilip/vim-lucius'
            Plug 'kaicataldo/material.vim'
            Plug 'dikiaap/minimalist'
            Plug 'NLKNguyen/papercolor-theme' " Papercolor
            Plug 'junegunn/seoul256.vim'
            " Probably not
            Plug 'challenger-deep-theme/vim' " challenger_deep
            Plug 'rakr/vim-two-firewatch' " two-firewatch
            Plug 'kristijanhusak/vim-hybrid-material'
            Plug 'altercation/vim-colors-solarized'
            Plug 'chriskempson/base16-vim'
            Plug 'nightsense/cosmic_latte' " cosmic_latte
            Plug 'flrnprz/candid.vim'
            Plug 'flrnprz/plastic.vim'
            Plug 'liuchengxu/space-vim-theme'
            Plug 'caksoylar/vim-mysticaltutor'
    call plug#end()

" Plugin Settings
    " Ale
        let g:ale_echo_cursor = 0
        let g:ale_echo_delay = 400
        let g:ale_echo_msg_format = '[%severity%] %code: %%s [%linter%]'
        let g:ale_fix_on_save = 1
        let g:ale_keep_list_window_open = 1
        let g:ale_list_window_size = 5
        " let g:ale_loclist_msg_format = '[%severity%] %code: %%s [%linter%]'
        let g:ale_set_signs = 0

        let g:ale_fixers = {
            \   'dart'      : ['dartfmt'],
            \   'python'    : ['autopep8'],
        \}

        " yapf for python?

        let g:ale_linters = {
            \   'dart'      : ['language_server'],
            \   'python'    : ['bandit', 'flake8', 'mypy'],
            \   'sh'        : ['language_server'],
        \}
            "   'python'    : ['flake8', 'mypy', 'pylint', 'bandit'],

    " Cool
        let g:CoolTotalMatches = 1

    " Dart
        " TODO: fix issues with dart plugin
            " sets indentexpr and cindent. expr overrides cindent anyway
            " use of cindent() seems to mess up. Check vs indent() and with
            " tabs and spaces
            " indentexpr defaulting to cindent seems to cause problems. It
            " returned a four-space indent when I tried it on this code at 
            " line ten (it returns 8 instead of 6) and line 13 (it returns 12
            " instead of 10). It also failed to work after running dartfmt. I
            " think the cinoptions set in the dart plugin might be off. (2s 
            " does not seem right. Same for u1s:

                " import 'package:flutter/material.dart';

                " void main() => runApp(MyApp());

                " class MyApp extends StatelessWidget {

                "     @override
                "     Widget build(BuildContext context) {
                "         return MaterialApp(
                "         home: Scaffold(
                "             appBar: AppBar(),
                "             body: Center(
                "             child: Text('Hello World'),
                "             ),
                "         ),
                "         );
                "     }
                " }

        let g:dart_html_in_string = v:true
        let g:dart_style_guide = 2

    " Flutter
        let s:flutter_filetypes = [
            \ 'dart',
            \ 'yaml',
        \ ]

    " Jedi
        " let g:jedi#show_call_signatures = 0

    " Indentline
        " TODO: set indentLine to use the final character of char_list for all
        " remaining indent levels on that line
        " https://github.com/Yggdroot/indentLine/blob/47648734706fb2cd0e4d4350f12157d1e5f4c465/after/plugin/indentLine.vim
        " let g:indentLine_char = '|'
        let g:indentLine_char_list = [' ', '|', ' ', 'Â¦', ' ', 'â”Š', ' ', 'â”Š',
            \ ' ', 'â”Š', ' ', 'â”Š', ' ', 'â”Š', ' ', 'â”Š', ' ', 'â”Š', ' ', 'â”Š',
        \]
        let g:indentLine_setColors = 0
        " let g:indentLine_first_char = ' '
        let g:indentLine_indentLevel = 20
        " let g:indentLine_showFirstIndentLevel = 0
        let g:indentLine_fileTypeExclude = [
            \   'help', 'quickfix', 'text', 'man',
        \   ]
        let g:indentLine_bufTypeExclude = [
            \   'help', 'quickfix', 'terminal', 'prompt', 'popup', 'nofile',
        \   ]
        " let g:indentLine_bufNameExclude = []
        " let g:indentLine_setConceal = 0
        let g:indentLine_concealcursor = 'n'
        let g:indentLine_conceallevel = 1

    " Netrw
        " let g:netrw_altfile
        " let g:netrw_alto
        " let g:netrw_altv
        let g:netrw_banner = 1
        let g:netrw_hide = 0
        let g:netrw_keepdir = 1
        let g:netrw_sizestyle = 'h'
        let g:netrw_sort_options = 'i'
        " let g:netrw_sort_by
            " :h :sort
        " NERDtree setup
            " let g:netrw_banner=0
            " let g:netrw_liststyle=3
            " let g:netrw_browse_split=4
            " let g:netrw_altv=1
            " let g:netrw_winsize=25
            " augroup ProjectDrawer
            "     autocmd!
            "     autocmd VimEnter * :Vexplore
            " augroup END

    " Python Syntax
        let g:python_highlight_all = 1
        let g:python_highlight_indent_errors = 1
        let g:python_highlight_space_errors = 0

    " Tmux
        " TODO: tmux plugin's indent file, line 41 should probably just return 
        " -1 instead of 0

" Vim Options
    " System integration settings
        set clipboard^=unnamed
        if has('mouse_sgr')
            set ttymouse=sgr
        else
            set ttymouse=xterm2
        end
        " TODO: check whether this should be 2000 or so
        set updatetime=750

    " Mouse settings
        set mouse=nvc

    " Disable flashing/beeping
        set belloff=all
        set noerrorbells

    " Text-editing settings
        " cpoptions (aABceFs default)
            " TODO: check these

        " cinoptions
            set cinoptions+=)1000
            set cinoptions+=*1000

        " formatoptions (tcq default)
            set formatoptions-=t
            set formatoptions+=r
            " set formatoptions+=w
            " set formatoptions+=a
            " set formatoptions+=n
            set formatoptions+=j

        " comments formatting
            set comments-=fb:-
            set comments+=b:-
            set comments+=b:+

        " Formatting and typing
            set autoindent
            set backspace=indent,eol,start,nostop
            set nojoinspaces

        " Tab/indent settings
            set tabstop=4
            set expandtab
            set softtabstop=0
            set shiftwidth=0
            set shiftround
            set smarttab

        " Completion settings
            set completeopt=menuone,popup,noinsert,noselect
            set completepopup=height:15,width:60,highlight:Pmenu,border:off,align:menu

    " Editor Settings
        " Search options
            set ignorecase
            set smartcase
            set wrapscan

        " Folding
            set foldenable
            set foldmethod=indent
            set foldlevelstart=8
            set foldminlines=3

        " Wrapping
            set wrap
            set linebreak
            set breakindent
            set breakindentopt=
            set showbreak=>\ 

        " Scrolling behavior
            set scrolloff=2
            set sidescroll=1
            set sidescrolloff=3

        " Sessions and views
            set sessionoptions=blank,curdir,help,resize,tabpages,winpos,winsize
            set sessionoptions+=winsize
            set viewoptions-=options

        " Window settings
            set previewpopup=height:12,width:60,highlight:Pmenu
            set noequalalways
            set cmdheight=2
            set cmdwinheight=12
            set laststatus=2
            set showtabline=2
            set winminheight=0
            set winminwidth=0
            set splitbelow
            set splitright
            set fillchars=vert:â”‚,fold:\ ,
            set listchars=tab:â€¹-â€º,trail:âˆ™,extends:â€º,precedes:â€¹,nbsp:âˆ…
            set pumheight=8

        " Mappings timeout
            set timeout
            set ttimeout
            set timeoutlen=3000
            set ttimeoutlen=10
            " TODO: check this vs matchit vs matchup
            " set matchpairs+=<:> " use % to jump between pairs

        " Display options
            " set noruler
            set report=0
            set display=lastline
            set incsearch
            set hlsearch
            set noshowmode
            set showcmd
            set shortmess-=f
            set shortmess-=l
            set shortmess-=n
            set shortmess-=x
            set shortmess-=O
            set shortmess-=t
            set shortmess-=T
            set shortmess+=c
            set shortmess-=S

        " Other
            set virtualedit=block
            set selection=old
            set wildmenu
            set autoread
            set nrformats-=octal
            set history=1000
            set tabpagemax=50
            set viminfo='100,<1000

" Source additional shitty personal vim files
    " TODO: refactor/reorganize additional personal vim files
    if isdirectory(expand('~/dotfiles/mvimfiles'))
        source ~/dotfiles/mvimfiles/highlight.vim
        " If colorscheme minimalist:
            " change red (statement?) to 204
            " change background to 235
            " change yellow to 214
        source ~/dotfiles/mvimfiles/status.vim
        source ~/dotfiles/mvimfiles/foldtext.vim
        source ~/dotfiles/mvimfiles/tab.vim

        set foldtext=GetFoldText()
        set tabline=%!SetTabLine()
    endif

" Abbreviations
    " Command-mode
        cnoreabbrev vh vert :h
        cnoreabbrev vman vert :Man
        cnoreabbrev vt vert :ter

        cnoreabbrev %%p <C-R>=expand('%:p:h')<CR>
        cnoreabbrev %%h <C-R>=expand('%:p')<CR>
        " cnoreabbrev seh e <C-R>=expand('%:p:h')<CR>/
        " cnoreabbrev veh e <C-R>=expand('%:p:h')<CR>/

        cnoreabbrev vrt*/ $VIMRUNTIME/**
        " cnoreabbrev vrt/ $VIMRUNTIME
        cnoreabbrev mv*/ <C-R>=substitute($MYVIMRC, '\m/vimrc$', '/**', '')<CR>
        " cnoreabbrev mv/ <C-R>=substitute($MYVIMRC, '\m/vimrc$', '', '')<CR>

" Commands
    command! Mvim edit $MYVIMRC
    command! Svim split $MYVIMRC
    command! Vvim vsplit $MYVIMRC

    command! HL call HL()

    command! MakeMinHeight call MakeMinHeight()
    command! MakeAppropriateHeight call MakeWindowAppropriateHeight()

    command! EchoStyleVim echo s:vim_style_names

" Mappings
    " Leader key
        nmap <Space> <leader>
        xmap <Space> <leader>
        omap <Space> <leader>
        " imap <C-F> <leader>
        " smap <C-F> <leader>
        " inoremap <C-F><C-F> <C-F>

    " General remappings
        " Comma will be used to initiate a lot of normal-mode mappings
        nnoremap ,, ,

        nnoremap Y y$

        " True deleting
        nnoremap ,c "_c
        xnoremap ,c "_c
        nnoremap ,C "_C
        xnoremap ,C "_C

        nnoremap ,d "_d
        xnoremap ,d "_d
        nnoremap ,D "_D
        xnoremap ,D "_D

        nnoremap ,x "_x
        xnoremap ,x "_x
        nnoremap ,X "_X
        xnoremap ,X "_X

        xnoremap > >gv
        xnoremap < <gv

        " nnoremap Q gq
        " xnoremap Q gq

        " Insert-mode mappings
        inoremap <C-U> <C-G>u<C-U>

        inoremap <C-A> <C-O>0
        inoremap <expr> <C-E> pumvisible() ? "\<C-E>" : "\<C-O>$"
        inoremap <C-X>a <C-A>
        inoremap <C-X>e <C-E>

        " TODO: set this only on terminals that need it
        imap <Nul> <C-Space>
        smap <Nul> <C-Space>

    " Pair-matching navigation mappings
        " TODO: remap square brackets to find nearest unmatched brackets
        " nnoremap [[ ?{<CR>w99[{
        " nnoremap ][ /}<CR>b99]}
        " nnoremap ]] j0[[%/{<CR>
        " nnoremap [] k$][%?}<CR>

    " Auto-pairing/auto-closing mappings
        let g:char_doubling = get(g:, 'char_doubling', 1)
        inoremap <silent><expr><C-G><C-G> ToggleCharDoubling()

        inoremap <silent><expr>( DoubledChar('(')
        inoremap <silent><expr>[ DoubledChar('[')
        inoremap <silent><expr>{ DoubledChar('{')
        inoremap <silent><expr> ' DoubledQuote("'")
        inoremap <silent><expr> " DoubledQuote('"')

        inoremap <C-G>3' ''''''<C-G>U<Left><C-G>U<Left><C-G>U<Left>
        inoremap <C-G>3" """"""<C-G>U<Left><C-G>U<Left><C-G>U<Left>

        inoremap <C-G>( (
        inoremap <C-G>[ [
        inoremap <C-G>{ {
        inoremap <C-G>" "
        inoremap <C-G>' '

        inoremap <silent><expr> ) NextClosingChar(')')
        inoremap <silent><expr> ] NextClosingChar(']')
        inoremap <silent><expr> } NextClosingChar('}')

        inoremap <C-G>) )
        inoremap <C-G>] ]
        inoremap <C-G>} }

        inoremap <silent><expr> <C-F>d DoubleChar()

    " Expansion mappings
        " Parentheses
        inoremap <silent><expr> (;<CR> DoubledCharExpanded('(', ';')
        inoremap <silent><expr> (; DoubledChar('(', ';')

        inoremap <silent><expr> (,<CR> DoubledCharExpanded('(', ',')
        inoremap <silent><expr> (, DoubledChar('(', ',')

        inoremap <silent><expr> (<CR> DoubledCharExpanded('(')

        " Curly braces
        inoremap <silent><expr> {;<CR> DoubledCharExpanded('{', ';')
        inoremap <silent><expr> {; DoubledChar('{', ';')

        inoremap <silent><expr> {,<CR> DoubledCharExpanded('{', ',')
        inoremap <silent><expr> {, DoubledChar('{', ',')

        inoremap <silent><expr> {<CR> DoubledCharExpanded('{')

        " Brackets
        inoremap <silent><expr> [;<CR> DoubledCharExpanded('[', ';')
        inoremap <silent><expr> [; DoubledChar('[', ';')

        inoremap <silent><expr> [,<CR> DoubledCharExpanded('[', ',')
        inoremap <silent><expr> [, DoubledChar('[', ',')

        inoremap <silent><expr> [<CR> DoubledCharExpanded('[')

        " Just expand
        inoremap <C-G>gs <CR><C-C>O

        " TODO: Turn this into a better function so it can just be one mapping
        "       gsb = split on parens | gs( | gs)
        "       gsB = split on curly | gs{ | gs}
        "       gs[ = split on brackets | gs[ | gs]
        nnoremap gs :call <SID>SplitBlock()<CR>O

    " Indentation mappings
        " TODO: sort through indentation mappings/functions. Get rid of
        " unnecessary ones, improve others. Implement functions which can take
        " a count
        nnoremap <silent><expr> [e FirstLineOfIndent(1, 0) . 'G'
        xnoremap <silent><expr> [e FirstLineOfIndent(1, 0) . 'G'
        onoremap <silent><expr> [e FirstLineOfIndent(1, 0) . 'G'

        nnoremap <silent><expr> ]e LastLineOfIndent(1, 0) . 'G'
        xnoremap <silent><expr> ]e LastLineOfIndent(1, 0) . 'G'
        onoremap <silent><expr> ]e LastLineOfIndent(1, 0) . 'G'

        nnoremap <silent><expr> [E FirstLineOfStrictIndent() . 'G'
        xnoremap <silent><expr> [E FirstLineOfStrictIndent() . 'G'
        onoremap <silent><expr> [E FirstLineOfStrictIndent() . 'G'

        nnoremap <silent><expr> ]E LastLineOfStrictIndent() . 'G'
        xnoremap <silent><expr> ]E LastLineOfStrictIndent() . 'G'
        onoremap <silent><expr> ]E LastLineOfStrictIndent() . 'G'

        nnoremap <silent><expr> <leader>ki FirstLineOfIndent(0, 0) . 'G'
        xnoremap <silent><expr> <leader>ki FirstLineOfIndent(0, 0) . 'G'
        onoremap <silent><expr> <leader>ki FirstLineOfIndent(0, 0) . 'G'

        nnoremap <silent><expr> <leader>ji LastLineOfIndent(0, 0) . 'G'
        xnoremap <silent><expr> <leader>ji LastLineOfIndent(0, 0) . 'G'
        onoremap <silent><expr> <leader>ji LastLineOfIndent(0, 0) . 'G'

        nnoremap <silent><expr> ]= LineOfEqualIndent(1) . 'G'
        xnoremap <silent><expr> ]= LineOfEqualIndent(1) . 'G'
        onoremap <silent><expr> ]= LineOfEqualIndent(1) . 'G'

        nnoremap <silent><expr> [= LineOfEqualIndent(0) . 'G'
        xnoremap <silent><expr> [= LineOfEqualIndent(0) . 'G'
        onoremap <silent><expr> [= LineOfEqualIndent(0) . 'G'

        nnoremap <silent><expr> ]- LineOfLessIndent(1) . 'G'
        xnoremap <silent><expr> ]- LineOfLessIndent(1) . 'G'
        onoremap <silent><expr> ]- LineOfLessIndent(1) . 'G'

        nnoremap <silent><expr> [- LineOfLessIndent(0) . 'G'
        xnoremap <silent><expr> [- LineOfLessIndent(0) . 'G'
        onoremap <silent><expr> [- LineOfLessIndent(0) . 'G'

        nnoremap <silent><expr> ]+ LineOfMoreIndent(1) . 'G'
        xnoremap <silent><expr> ]+ LineOfMoreIndent(1) . 'G'
        onoremap <silent><expr> ]+ LineOfMoreIndent(1) . 'G'

        nnoremap <silent><expr> [+ LineOfMoreIndent(0) . 'G'
        xnoremap <silent><expr> [+ LineOfMoreIndent(0) . 'G'
        onoremap <silent><expr> [+ LineOfMoreIndent(0) . 'G'

        xnoremap <silent> ii :<C-U>call SelectInIndent(1, 1)<CR>
        onoremap <silent> ii :<C-U>call SelectInIndent(1, 1)<CR>

        xnoremap <silent> ai :<C-U>call SelectAroundIndent(1)<CR>
        onoremap <silent> ai :<C-U>call SelectAroundIndent(1)<CR>

        xnoremap <silent> iI :<C-U>call SelectStrictIndent()<CR>
        onoremap <silent> iI :<C-U>call SelectStrictIndent()<CR>

        xnoremap <silent> aI :<C-U>call SelectAroundIndent(0)<CR>
        onoremap <silent> aI :<C-U>call SelectAroundIndent(0)<CR>

        " TODO: implement these bracket-indent mappings maybe
            " map ]] and [[ to match next unmatched brackets

            " map ][ does not include blanks
            " map [] does include blanks

            " map ][= and []= to select all lines of same indent not
            " including more-indented lines
            " map ][- and []- to select all lines of the same indent and
            " more-indented lines
            " map ][+ and []+ to select all lines of the same indent
            " including more-indented liens and one less-indented line on
            " each side
            " map ][[+ and [][+ to select the same but only the
            " less-indented line above
            " map ][]+ and []]+ to select the same but only the
            " less-indented line below

    " Line-object mappings
        xnoremap <silent> il :<C-U>normal! g_v^<CR>
        onoremap <silent> il :<C-U>normal! g_v^<CR>

        xnoremap <silent> al :<C-U>normal! $v0<CR>
        onoremap <silent> al :<C-U>normal! $v0<CR>

    " Tab/enter/backspace/space key mappings
        " Tab
            inoremap <silent><expr> <TAB> MapTab()
            imap <C-G><Tab> <Tab>

        " Enter
            " inoremap <expr> <CR> pumvisible() ? "\<C-Y>\<CR>" : "\<CR>"
            " TODO: make these ovey g:char_doubling or something similar
            " inoremap ;<CR> <C-C>A;<CR>
            " inoremap <C-G>; ;
            " inoremap ,<CR> <C-C>A,<CR>
            " inoremap <C-G>, ,
            " inoremap <CR> <C-C>A<CR>
            inoremap <C-G><CR> <CR>
            " inoremap <C-G>s<CR> <CR><C-C>O
            inoremap <C-G>gs <CR><C-C>O
            inoremap <silent><expr> <CR> MapEnter()

        " Backspace
            " inoremap <silent><expr> <BS> pumvisible()
            "     \ ? "\<C-E>"
            "     \ : MapBackspace()
            inoremap <silent><expr> <BS> MapBackspace()

        " Space
            inoremap <C-G><Space> <Space><Space><C-G>U<Left>

    " Plugin mappings
        " Ale
            function! SetALEMappings(filetype) abort
                if exists(':ALEInfo') == 2 && (len(ale#linter#Get(a:filetype)) > 0)
                    " nmap <buffer> <leader>ad <Plug>(ale_detail)
                    " nmap <buffer> <leader>ah <Plug>(ale_hover)
                    nmap <silent><buffer> <leader>aqn <Plug>(ale_next_wrap)
                    nmap <silent><buffer> <leader>aqp <Plug>(ale_previous_wrap)
                    nmap <silent><buffer> <leader>aqf <Plug>(ale_first)
                    nmap <silent><buffer> <leader>aql <Plug>(ale_last)
                endif
            endfunction

        " EasyAlign
            function! SetEasyAlignMappings() abort
                if exists(':EasyAlign') == 2
                    nmap <leader>ea <Plug>(EasyAlign)
                    xmap <leader>ea <Plug>(EasyAlign)
                    " xmap <CR> <Plug>(EasyAlign)
                    nmap <leader>el <Plug>(LiveEasyAlign)
                    xmap <leader>el <Plug>(LiveEasyAlign)
                endif
            endfunction

        " Flutter
            function! SetFlutterMappings(filetype) abort
                if exists(':FlutterRun') == 2 && index(s:flutter_filetypes,
                    \   a:filetype, '', v:true) != -1
                    nnoremap <buffer><leader>frl :FlutterHotReload
                    nnoremap <buffer><leader>frs :FlutterHotRestart
                    nnoremap <buffer><leader>fvd :FlutterVisualDebug
                endif
            endfunction

" augroups
    " General
        " augroup go_to_last_edit
        "     autocmd!

            " Found online
                " autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

            " Found in defaults.vim
                " autocmd BufReadPost *
                    " \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
                    " \ |   exe "normal! g`\""
                    " \ | endif
        " augroup END

    " Statusline/tabline
        augroup statusline_update
            autocmd!
            autocmd TextChanged,CompleteChanged,CursorHold,InsertChange * let &l:statusline = &l:statusline
        augroup END

        augroup set_statuslines
            autocmd!
            " call Filetype,SessionLoadPost,CursorMoved,BufUnload
            autocmd TerminalOpen,BufWinEnter,BufEnter,WinEnter,Filetype * call SetStatusLineActive()
            autocmd Filetype netrw call SetStatusLineActive()
            autocmd BufLeave,WinLeave * call SetStatusLineInactive()
        augroup END

        augroup set_tab_line
            autocmd!
            autocmd VimEnter,BufEnter,BufWinEnter,WinEnter,WinNew * call SetTabLine()
            autocmd WinLeave,BufLeave * call SetTabLine()
        augroup END

    augroup set_list_chars
        autocmd!
        autocmd InsertEnter * set listchars=tab:Â«-Â»,extends:â€º,precedes:â€¹,nbsp:âˆ…
        autocmd InsertLeave * set listchars=tab:Â«-Â»,trail:âˆ™,extends:â€º,precedes:â€¹,nbsp:âˆ…
    augroup END

" Functions and Variables
    " Command functions/variables
        function! MakeWindowMinHeight() abort
            let height = winheight('.')
            let length = line('$')

            if length < height
                execute "normal! \<C-W>" . length . '_'
            endif
        endfunction

        function! MakeWindowAppropriateHeight(max = 0) abort
            let length = line('$')

            let full = a:max == 0
                        \ ? length
                        \ : a:max <= length
                            \ ? a:max
                            \ : length

            execute "normal! \<C-W>" . full . '_'
        endfunction

        let s:vim_style_names = "Names:
            \\n    plugin-names-like-this
            \\n    FunctionNamesLikeThis
            \\n    CommandNamesLikeThis
            \\n    augroup_names_like_this
            \\n    variable_names_like_this
            \\nReserved variables: (unless scriptversion 3)
            \\n    count
            \\n    errmsg
            \\n    shell_error
            \\n    this_session
            \\n    version"

    " Mapping functions/variables
        " Pairing dictionaries
            " TODO: go through functions and ensure they all use the proper
            " dictionary. A few might be able to be simplified.

            let s:char_pairs_asymmetric = {
                \ '(': ')',
                \ '[': ']',
                \ '{': '}',
            \ }

            let s:char_pairs_symmetric = {
                \ '"': '"',
                \ "'": "'",
            \ }

            let s:char_pairs_asymmetric_escaped = 
                \ deepcopy(s:char_pairs_asymmetric)
            " unlet s:char_pairs_asymmetric_escaped['[']
            let s:char_pairs_asymmetric_escaped['['] = '\]'
            let s:char_pairs_asymmetric_escaped['\['] = '\]'

            let s:char_pairs = deepcopy(s:char_pairs_asymmetric)
            call extend(s:char_pairs, s:char_pairs_symmetric)

            let s:char_pairs_escaped = deepcopy(s:char_pairs_asymmetric_escaped)
            call extend(s:char_pairs_escaped, s:char_pairs_symmetric)

        " Auto-pairing/auto-closing functions and variables
            function! NextClosingChar(char) abort
                let doubling = exists('b:char_doubling') ?
                    \ b:char_doubling
                    \ : g:char_doubling

                if doubling && search('\m\%#.\{-,}' . a:char)
                    " TODO: test whether this change must be made
                    " return "\<Esc>f" . a:char . "\<Esc>a"
                    return "\<C-C>f" . a:char . 'a'
                else
                    return a:char
                endif
            endfunction

            function! DoubleChar() abort
                let key = GetCharBeforeCursor()

                if has_key(s:char_pairs, key)
                    return s:char_pairs[key] . "\<C-G>U\<Left>"
                elseif key == '<'
                    return ">\<C-G>U\<Left>"
                else
                    return ''
                endif
            endfunction

            function! MapBackspace() abort
                let doubling = get(b:, 'char_doubling', g:char_doubling)
                if !doubling
                    return "\<BS>"
                endif

                let bs_delete = "\<BS>\<Del>"

                for k in keys(s:char_pairs_escaped)
                    if search('\m' . k . '\%#' . s:char_pairs_escaped[k])
                        return bs_delete
                    elseif search('\m' . k . ' \%# ' . s:char_pairs_escaped[k])
                        return bs_delete
                    endif
                endfor

                " TODO: make this return multiple backspaces when softtabstop
                " is off and the cursor is after multiple spaces

                return "\<BS>"
            endfunction

            " Look into whether shiftwidth([{col}]) would be useful, along
            " with vartabstop
            function! MapTab() abort
                " let doubling = get(b:, 'char_doubling', g:char_doubling)
                let smart_tab = InsertSmartTab()

                if &l:expandtab
                    return "\<Tab>"
                " elseif !doubling
                "     return smart_tab
                elseif search('\m\(^\|\s\)\%#\(\s\|$\)')
                    return smart_tab
                elseif search('\m\%#\s*$')
                    return smart_tab
                elseif search('\m^\s*\%#')
                    return smart_tab
                else
                    return "\<C-O>:call NextDelimiter()\<CR>"
                endif
            endfunction

            function! MapEnter() abort
                let doubling = get(b:, 'char_doubling', g:char_doubling)

                if !doubling
                    return "\<CR>"
                elseif search('\m\%#$')
                    return "\<CR>"
                elseif search('\m\%#.\+$')
                    return "\<C-C>A"
                else
                    return "\<CR>"
                endif
            endfunction

            function! NextDelimiter() abort
                call search('\m\%#.\{-,}\((\|)\|{\|}\|\[\|]\|''\|"\|,\|;\|<\|>\|$\)\zs', 'e')
            endfunction

            function! ToggleCharDoubling() abort
                if exists('b:char_doubling')
                    let b:char_doubling = !b:char_doubling
                else
                    let g:char_doubling = !g:char_doubling
                endif
                return ''
            endfunction

            function! DoubledChar(char, delimiter = '') abort
                let doubling = get(b:, 'char_doubling', g:char_doubling)

                if !empty(a:delimiter)
                    let end_chars = a:delimiter . "\<C-G>U\<Left>"
                else
                    let end_chars = ''
                endif

                if doubling
                    return a:char . s:char_pairs[a:char] . end_chars . 
                        \ "\<C-G>U\<Left>"
                elseif !empty(a:delimiter)
                    return a:char . a:delimiter . "\<Space>"
                else
                    return a:char . a:delimiter
                endif
            endfunction

            function! DoubledCharExpanded(char, delimiter = '') abort
                let doubling = get(b:, 'char_doubling', g:char_doubling)

                if doubling
                    return a:char . "\<CR>" . s:char_pairs[a:char] .
                                \ a:delimiter . "\<C-C>O"
                else
                    return a:char . a:delimiter . "\<CR>"
                endif
            endfunction

            function! DoubledQuote(char) abort
                let doubling = get(b:, 'char_doubling', g:char_doubling)
                let right_char = GetCharAfterCursor()

                if doubling && right_char == a:char
                    return "\<C-G>U\<Right>"
                elseif doubling
                    return a:char . a:char . "\<C-G>U\<Left>"
                else
                    return a:char
                endif
            endfunction

        " Expansion functions and variables
            let s:block_pairs = {
                \ '(':    ')',
                \ ')':    ')',
                \ '[':    ']',
                \ ']':    ']',
                \ '{':    '}',
                \ '}':    '}',
            \ }

            function! s:SplitBlock() abort
                let char = s:GetCursorChar()

                if char =~? '(\|[\|{'
                    execute "normal! la\<BS>\<CR>" . s:block_pairs[char]
                elseif char =~? ')\|]\|}'
                    execute "normal! a\<BS>\<CR>" . s:block_pairs[char]
                endif
            endfunction

        " Indentation mappings
            function! MostIndentedNeighbor(default_forward) abort
                let pos = line('.')

                let prev = search('\m.\+', 'bn')
                let next = search('\m.\+', 'n')
                let default = a:default_forward ? next : prev

                if prev ==# 0 && next ==# 0
                    return pos
                elseif prev == next
                    return default
                else
                    return indent(prev) > indent(next) ? prev : next
                endif
            endfunction

            function! LeastIndentedNeighbor(default_forward) abort
                let pos = line('.')

                let prev = search('\m.\+', 'bn')
                let next = search('\m.\+', 'n')
                let default = a:default_forward ? next : prev

                if prev ==# 0 && next ==# 0
                    return pos
                elseif prev == next
                    return default
                else
                    return indent(prev) < indent(next) ? prev : next
                endif
            endfunction

            function! FirstLineOfIndent(include_blanks, end_on_blank) abort
                if getline('.') =~# '\m^\s*$'
                    let start_indent = indent(MostIndentedNeighbor(0))
                else
                    let start_indent = indent('.')
                endif

                if start_indent == 0
                    return FirstLineOfStrictIndent()
                endif

                let return_line = line('.')

                for x in range(line('.') - 1, 1, -1)
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if (x_indent < start_indent && !blank) || (blank && !a:include_blanks)
                        return return_line
                    elseif !blank || (blank && a:end_on_blank)
                        let return_line = x
                    endif
                endfor

                return return_line
            endfunction

            function! LastLineOfIndent(include_blanks, end_on_blank) abort
                if getline('.') =~# '\m^\s*$'
                    let start_indent = indent(MostIndentedNeighbor(1))
                else
                    let start_indent = indent('.')
                endif

                if start_indent == 0
                    return LastLineOfStrictIndent()
                endif

                let return_line = line('.')

                for x in range(line('.') + 1, line('$'))
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if (x_indent < start_indent && !blank) || (blank && !a:include_blanks)
                        return return_line
                    elseif !blank || (blank && a:end_on_blank)
                        let return_line = x
                    endif
                endfor

                return return_line
            endfunction

            function! FirstLineOfStrictIndent() abort
                let start_indent = indent('.')

                for x in range(line('.') - 1, 1, -1)
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if x_indent !=# start_indent || blank
                        return x + 1
                    endif
                endfor

                return line('.')
            endfunction

            function! LastLineOfStrictIndent() abort
                let start_indent = indent('.')

                for x in range(line('.') + 1, line('$'))
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if x_indent !=# start_indent || blank
                        return x - 1
                    endif
                endfor

                return line('.')
            endfunction

            function! LineOfEqualIndent(forward) abort
                if getline('.') =~# '\m^\s*$'
                    return line('.')
                endif

                let start_indent = indent('.')
                let step = a:forward ? 1 : -1
                let end = a:forward ? line('$') : 1

                for x in range(line('.') + step, end, step)
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if x_indent == start_indent && !blank
                        return x
                    elseif x_indent < start_indent && !blank
                        return line('.')
                    endif
                endfor

                return line('.')
            endfunction

            function! LineOfLessIndent(forward) abort
                if getline('.') =~# '\m^\s*$'
                    let start_line = MostIndentedNeighbor(1)
                else
                    let start_line = line('.')
                endif

                let step = a:forward ? 1 : -1
                let end = a:forward ? line('$') : 1
                let start_indent = indent(start_line)

                for x in range(start_line + step, end, step)
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if x_indent < start_indent && !blank
                        return x
                    endif
                endfor

                return line('.')
            endfunction

            function! LineOfMoreIndent(forward) abort
                if getline('.') =~# '\m^\s*$'
                    " let search = a:forward ? 'n' : 'bn'
                    let start_line = LeastIndentedNeighbor(!a:forward)
                else
                    let start_line = line('.')
                endif

                let step = a:forward ? 1 : -1
                let end = a:forward ? line('$') : 1
                let start_indent = indent(start_line)

                for x in range(start_line + step, end, step)
                    let x_indent = indent(x)
                    let blank = getline(x) =~# '\m^\s*$'

                    if x_indent > start_indent && !blank
                        return x
                    elseif x_indent < start_indent && !blank
                        return line('.')
                    endif
                endfor

                return line('.')
            endfunction

            function! SelectInIndent(include_blanks, end_on_blank) abort
                let start = FirstLineOfIndent(a:include_blanks, a:end_on_blank)
                let end = LastLineOfIndent(a:include_blanks, a:end_on_blank)

                execute 'normal! ' . start . 'GV' . end . 'G'
            endfunction

            function! SelectAroundIndent(include_trailing) abort
                let start = LineOfLessIndent(0)
                let end = a:include_trailing ?
                    \ LineOfLessIndent(1) :
                    \ LastLineOfIndent(1, 0)

                execute 'normal! ' . start . 'GV' . end . 'G'
            endfunction

            function! SelectStrictIndent() abort
                let start = FirstLineOfStrictIndent()
                let end = LastLineOfStrictIndent()

                execute 'normal! ' . start . 'GV' . end . 'G'
            endfunction

        " Tab Mapping Experiment
            " inoremap <silent><expr> <Tab> InsertTabOrSpace()

            " <C-T> and <C-D> don't work even if this does. So this whole idea
            " needs work.
            " function! InsertTabOrSpace() abort
            "     if search('\m^\s*\%#.*$')
            "         return "\<C-V>\<Tab>"
            "     else
            "         return "\<Tab>"
            "     endif
            " endfunction

            function! InsertSmartTab() abort
                if search('\m^\s*\%#.*$')
                    return "\<Tab>"
                endif

                " try
                "     let myexpandtab = &expandtab
                "     set expandtab
                "     return "\<Tab>"
                " finally
                "     let &expandtab = myexpandtab
                " endtry

                let col = virtcol('.') - 1
                let tab_stop = &tabstop
                let len = tab_stop - (col % tab_stop)
                let ret_str = repeat(' ', len)
                return ret_str
            endfunction

    " Utility functions/vars
        function! GetCharAfterCursor() abort
            return matchstr(getline('.'), '\%' . col('.') . 'c.')
        endfunction

        function! GetCharBeforeCursor() abort
            return matchstr(getline('.'), '\%' . (col('.') - 1) . 'c.')
        endfunction

        function! s:GetCursorChar()
            let col = virtcol('.') - 1
            let char = strcharpart(getline('.'), col, 1)
            return char
        endfunction

    " Other functions/variables
        function! HL() abort
            echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), '/')
        endfunction
