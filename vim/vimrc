scriptencoding utf-8

" Stuff to do
    " TODO: does fedora always load a file to the last opened position? And if
    " so, why does this not happen in ubuntu? (This is currently being set by
    " an autocmd in ubuntu)
    " TODO: figure out 'path' (see tpope's apathy)
    " TODO: fix problem with arrow keys in insert mode
        " set term=builtin_ansi works for some reason

" Style
    " plugin-names-like-this
    " FunctionNamesLikeThis
    " CommandNamesLikeThis
    " augroup_names_like_this
    " variable_names_like_this

" install vim-plug if it is not already
    if has('unix') || has('mac') || has('macunix')
        if empty(glob('~/.vim/autoload/plug.vim')) && executable('curl')
            silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
            augroup InstallVimPlug
                autocmd!
                autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
            augroup END
        elseif empty(glob('~/.vim/autoload/plug.vim')) && !executable('curl')
            unlet! skip_defaults_vim
            source $VIMRUNTIME/defaults.vim
            finish
        endif
    elseif has('win32') || has('win64')
        unlet! skip_defaults_vim
        source $VIMRUNTIME/defaults.vim
        finish
    elseif has('win32unix')
        unlet! skip_defaults_vim
        source $VIMRUNTIME/defaults.vim
        finish
    else
        unlet! skip_defaults_vim
        source $VIMRUNTIME/defaults.vim
        finish
    endif

" set runtimepath+=~/zotes/learning/plugin/mpc/
runtime! ftplugin/man.vim
packadd! matchit
packadd! cfilter

set background=dark

augroup go_to_last_edit
    autocmd!
    autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
augroup END

" Cursor Settings
    " This      Means this
    " &t_SI     Insert mode
    " &t_SR     Replace mode
    " &t_EI     Normal mode

    "  1 -> blinking block
    "  2 -> solid block 
    "  3 -> blinking underscore
    "  4 -> solid underscore
    "  5 -> blinking vertical bar
    "  6 -> solid vertical bar

    if $TERM_PROGRAM =~? 'Apple_Terminal'
        let &t_SI = "\e[5 q"
        let &t_SR = "\e[3 q"
        let &t_EI = "\e[1 q"
    elseif $TERM =~? 'xterm' && !exists('$TMUX')
        let &t_SI = "\<Esc>[5 q"
        let &t_SR = "\<Esc>[3 q"
        let &t_EI = "\<Esc>[1 q"
    elseif $TERM =~? 'xterm\|tmux' && exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>[5 q\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>[3 q\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>[1 q\<Esc>\\"
    elseif $TERM_PROGRAM =~? 'iTerm\|xterm' && !exists('$TMUX')
        let &t_SI = "\<Esc>]50;CursorShape=1\x7"
        let &t_SR = "\<Esc>]50;CursorShape=2\x7"
        let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    elseif $TERM_PROGRAM =~? 'iTerm\|xterm' && exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    elseif exists('$TMUX')
        let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
        let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
        let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    else
        let &t_SI = "\<Esc>]50;CursorShape=1\x7"
        let &t_SR = "\<Esc>]50;CursorShape=2\x7"
        let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    endif

call plug#begin('~/.vim/plugged')
    " junegunn
        Plug 'junegunn/vim-easy-align'
        Plug 'junegunn/vim-plug'
    " romainl
        Plug 'romainl/vim-cool'
        " Plug 'romainl/vim-qf'
    " tpope
        " Plug 'tpope/vim-abolish'
        Plug 'tpope/vim-commentary'
        if executable('git')
            Plug 'tpope/vim-fugitive'
        endif
        Plug 'tpope/vim-repeat'
        Plug 'tpope/vim-surround'
        Plug 'tpope/vim-unimpaired'
        Plug 'tpope/vim-vinegar'
    " Appearance
        Plug 'yggdroot/indentline'
        " Plug 'majutsushi/tagbar'
        " Plug 'airblade/vim-gitgutter'
        " Plug 'mhinz/vim-signify'
    " Editing
        " Plug 'osyo-manga/vim-over'
        " Plug 'markonm/traces.vim'
        " Plug 'haya14busa/incsearch.vim'
        " Plug 'AndrewRadev/splitjoin.vim'
        " Plug 'jiangmiao/auto-pairs'
        " Plug 'tomtom/tcomment_vim'
        " Plug 'andymass/vim-matchup'
        " Plug 'svermeulen/vim-subversive'
    " Linting/completion
        Plug 'dense-analysis/ale'
        if executable('node') || executable('npm')
            Plug 'neoclide/coc.nvim', {'branch': 'release'}
        endif
        " Plug 'natebosch/vim-lsc'
        " Plug 'natebosch/vim-lsc-dart'
    " Language/framework/filetype
        Plug 'dart-lang/dart-vim-plugin'
        if executable('flutter')
            Plug 'thosakwe/vim-flutter'
        endif
        Plug 'tmux-plugins/vim-tmux'
        " Plug 'python-mode/python-mode'
    " Other
        " Plug 'xolox/vim-easytags'
        " Plug 'jlanzarotta/bufexplorer'
    " Colorschemes
        " Actually might use
        Plug 'romainl/Apprentice'
        Plug 'nanotech/jellybeans.vim'
        Plug 'aonemd/kuroi.vim'
        Plug 'dikiaap/minimalist'
        Plug 'NLKNguyen/papercolor-theme' " Papercolor
        " Probably not
        Plug 'challenger-deep-theme/vim' " challenger_deep
        Plug 'rakr/vim-two-firewatch' " two-firewatch
        Plug 'kristijanhusak/vim-hybrid-material'
        Plug 'altercation/vim-colors-solarized'
        Plug 'chriskempson/base16-vim'
        Plug 'nightsense/cosmic_latte' " cosmic_latte
        Plug 'flrnprz/candid.vim'
        Plug 'flrnprz/plastic.vim'
        Plug 'liuchengxu/space-vim-theme'
        Plug 'sainnhe/vim-color-forest-night'
        Plug 'caksoylar/vim-mysticaltutor'
call plug#end()

colorscheme cosmic_latte

" Plugin Settings
    " Ale
        " Other things
            " install flake8 with 'python -m pip install flake8'
            " install pylint with 'pip install pylint'
            " install mypu with 'python -m pip install -U mypy'
            " install bandit with 'pip install bandit'
            " install autopep8 with 'pip install --upgrade autopep8'

        let g:ale_echo_delay = 50
        let g:ale_echo_msg_format = '[%severity%] %code: %%s [%linter%]'
        let g:ale_fix_on_save = 1
        let g:ale_keep_list_window_open = 1
        let g:ale_list_window_size = 5
        let g:ale_loclist_msg_format = '[%severity%] %code: %%s [%linter%]'
        let g:ale_set_signs = 0

        let g:ale_fixers = {
            \   'dart'      : ['dartfmt'],
            \   'python'    : ['autopep8'],
        \}

        let g:ale_linters = {
            \   'dart'      : ['language_server'],
            \   'python'    : ['flake8', 'mypy', 'pylint', 'bandit'],
            \   'sh'        : ['language_server'],
        \}

    " Coc
        " Use this for autocmd mappings
            let s:coc_filetypes = [
                \ 'dart',
                \ 'vim',
                \ 'sh',
            \ ]


    " Cool
        let g:CoolTotalMatches = 1

    " Dart
        " TODO: fix issues with dart plugin
            " sets indentexpr and cindent. expr overrides cindent anyway
            " use of cindent() seems to mess up. Check vs indent() and with
            " tabs and spaces
            " indentexpr defaulting to cindent seems to cause problems. It
            " returned a four-space indent when I tried it on this code at 
            " line ten (it returns 8 instead of 6) and line 13 (it returns 12
            " instead of 10). It also failed to work after running dartfmt. I
            " think the cinoptions set in the dart plugin might be off. (2s 
            " does not seem right. Same for u1s:

                " import 'package:flutter/material.dart';

                " void main() => runApp(MyApp());

                " class MyApp extends StatelessWidget {

                "     @override
                "     Widget build(BuildContext context) {
                "         return MaterialApp(
                "         home: Scaffold(
                "             appBar: AppBar(),
                "             body: Center(
                "             child: Text('Hello World'),
                "             ),
                "         ),
                "         );
                "     }
                " }

        let g:dart_html_in_string = v:true
        let g:dart_style_guide = 2

    " Flutter
        let s:flutter_filetypes = [
            \ 'dart',
            \ 'yaml',
        \ ]

    " Indentline
        " TODO: set indentLine to use the final character of char_list for all
        " remaining indent levels on that line
        " https://github.com/Yggdroot/indentLine/blob/47648734706fb2cd0e4d4350f12157d1e5f4c465/after/plugin/indentLine.vim
        " let g:indentLine_char = '|'
        let g:indentLine_char_list = [' ', '|', ' ', '¦', ' ', '┊', ' ', '┊',
            \ ' ', '┊', ' ', '┊', ' ', '┊', ' ', '┊', ' ', '┊', ' ', '┊',
        \]
        let g:indentLine_indentLevel = 20
        let g:indentLine_fileTypeExclude = ['help', 'quickfix', 'text', ]
        let g:indentLine_bufTypeExclude = ['help', 'quickfix',]
        " let g:indentLine_bufNameExclude = []

    " Lsc
        " let g:lsc_server_commands = {'dart': 'dart_language_server'}
        " let g:lsc_auto_map = v:true

    " Netrw
        " let g:netrw_altfile
        " let g:netrw_alto
        " let g:netrw_altv
        let g:netrw_banner = 1
        let g:netrw_hide = 0
        let g:netrw_keepdir = 1
        let g:netrw_sizestyle = 'h'
        let g:netrw_sort_options = 'i'
        " let g:netrw_sort_by
            " :h :sort
        " NERDtree setup
            " let g:netrw_banner=0
            " let g:netrw_liststyle=3
            " let g:netrw_browse_split=4
            " let g:netrw_altv=1
            " let g:netrw_winsize=25
            " augroup ProjectDrawer
            "     autocmd!
            "     autocmd VimEnter * :Vexplore
            " augroup END

    " Tmux
        " TODO: tmux plugin's indent file, line 41 should probably just return 
        " -1 instead of 0

" Vim Options
    " System integration settings
        set clipboard^=unnamed
        if has('mouse_sgr')
            set ttymouse=sgr
        else
            set ttymouse=xterm2
        end
        set updatetime=2000

    " Mouse settings
        set mouse=nvc

    " Disable flashing/beeping
        set belloff=all
        set noerrorbells

    " Text-editing settings
        " cpoptions (aABceFs default)

        " formatoptions (tcq default)
            set formatoptions-=t
            set formatoptions+=r
            " set formatoptions+=w
            " set formatoptions+=a
            " set formatoptions+=n
            set formatoptions+=j

        " comments formatting
            set comments-=fb:-
            set comments+=b:-
            set comments+=b:+

        " Formatting and typing
            set autoindent
            set backspace=indent,eol,start
            set nojoinspaces

        " Tab/indent settings
            set tabstop=4
            set expandtab
            set softtabstop=-1
            set shiftwidth=0
            set shiftround
            set smarttab

        " Completion settings
            set completeopt=menuone,popup,noinsert,noselect

    " Editor Settings
        " Search options
            set ignorecase
            set smartcase
            set wrapscan

        " Folding
            set foldenable
            set foldmethod=indent
            set foldlevelstart=99
            set foldminlines=3

        " Wrapping
            set wrap
            set linebreak
            set breakindent
            set breakindentopt=
            set showbreak=>>\ 

        " Scrolling behavior
            set scrolloff=3
            set sidescroll=1
            set sidescrolloff=3

        " Sessions and views
            set sessionoptions=blank,curdir,help,resize,tabpages,winpos,winsize
            set sessionoptions+=winsize
            set viewoptions-=options

        " Window settings
            set previewpopup=height:12,width:60,highlight:Pmenu
            set noequalalways
            set cmdheight=2
            set cmdwinheight=12
            set laststatus=2
            set showtabline=2
            set winminheight=0
            set winminwidth=0
            set splitbelow
            set splitright
            set fillchars=vert:│,fold:\ ,
            set listchars=tab:‹\ ›,trail:∙,extends:›,precedes:‹,nbsp:∅
            set pumheight=8

        " Mappings timeout
            set timeout
            set ttimeout
            set timeoutlen=3000
            set ttimeoutlen=100
            " TODO: check this vs matchit vs matchup
            " set matchpairs+=<:> " use % to jump between pairs

        " Display options
            set report=0
            set display=lastline
            set incsearch
            set hlsearch
            set noshowmode
            set showcmd
            set shortmess-=f
            set shortmess-=l
            set shortmess-=n
            set shortmess-=x
            set shortmess-=O
            set shortmess-=t
            set shortmess-=T
            set shortmess+=c
            set shortmess-=S

        " Other
            set virtualedit=block
            set selection=old
            set wildmenu
            set autoread
            set nrformats-=octal
            set history=1000
            set tabpagemax=50
            set viminfo='100,<1000

" Commands
    command! Mvim edit $MYVIMRC
    command! Svim split $MYVIMRC
    command! Vvim vsplit $MYVIMRC

    command! StyleVim echo s:vim_style_names
    " command! StyleDart echo s:dart_style_names
    " command! Style (takes an argument here, gets list of style to echo from
    " a dictionary of styles

    " command to set window to height of its lines
    " command to set window to width of its columns
    " command to switch to window N
    " command to switch this window's buffer with another

    let s:vim_style_names = "plugin-names-like-this
        \ \nFunctionNamesLikeThis
        \ \nCommandNamesLikeThis
        \ \naugroup_names_like_this
        \ \nvariable_names_like_this"

    " TODO: create a buffer where you can write vimscript and execute it 
    " easily. See :h scratch for the buffer settings to use
    " command! Scratch call OpenVimScratch()
    " TODO: write a vertical scratch
    " command! Vscratch call OpenVimScratch(1)

    " function! OpenVimScratch() abort
        " if a:arg is 0, new, else vnew
        " if 'vim scratch' already exists, switch to it. Or still open a split
        " and switch to it
        " new
        " file [vim scratch]
        " setlocal buftype=nofile
        " setlocal nobuflisted
        " setlocal filetype=vim
        " setlocal bufhidden=hide
        " setlocal noswapfile
    " endfunction

" Mappings
    " Leader mappings
        nmap <Space> <leader>
        xmap <Space> <leader>

    " Vim default remappings
        " TODO: remap square brackets to find nearest unmatched brackets
        nnoremap [[ ?{<CR>w99[{
        nnoremap ][ /}<CR>b99]}
        nnoremap ]] j0[[%/{<CR>
        nnoremap [] k$][%?}<CR>

        nnoremap Y y$

        xnoremap > >gv
        xnoremap < <gv

        " TODO: remap ;<cr> to add a semicolon to the end of the line and then
        " press enter

        " TODO: remap <cr><cr> to go to end of line and enter

        " TODO: maybe remap ',",),],} to <right arrow> if that character is
        " already to the right of the cursor? GetCursorChar() gets that
        " character

        " TODO: map auto-closing or find one to use

        " TODO: remap brackets to move to indent levels?
            " [[ move to beginning of current or previous (higher or lower,
            " either one) indent
            " [] move to end of previous indent
            " ]] move to end of current or following indent
            " ][ move to beginning of following indent

            " next unmatched bracket
            " prev unmatched bracket

            " start of current indent
            " end of current indent
            " start of prev indent
            " end of prev indent " line before current indent
            " start of next indent " line after current indent
            " end of next indent

        " TODO: remap c and d to not affect yank history. Maybe have yd or dy
        " yank a whole line and delete it? d<motion> could delete into empty
        " register and yd<motion> could delete but with the deleted text
        " yanked. Same for c<motion> and yc<motion>.

        " Remap arrow keys? To :cnext, :lnext

        let s:pairs = ['.', ':', ',', ';', '<bar>', '/', '<bslash>', '*',]
        for s:key in s:pairs
            execute 'nnoremap ci' . s:key . ' T' . s:key . 'ct' . s:key
            execute 'nnoremap di' . s:key . ' T' . s:key . 'dt' . s:key
            execute 'nnoremap yi' . s:key . ' T' . s:key . 'yt' . s:key
            execute 'nnoremap vi' . s:key . ' T' . s:key . 'vt' . s:key
            execute 'nnoremap ca' . s:key . ' F' . s:key . 'cf' . s:key
            execute 'nnoremap da' . s:key . ' F' . s:key . 'df' . s:key
            execute 'nnoremap ya' . s:key . ' F' . s:key . 'yf' . s:key
            execute 'nnoremap va' . s:key . ' F' . s:key . 'vf' . s:key
        endfor

        augroup helpfile_navigation
            autocmd!
            " It seems there is no terminal filetype set
            autocmd Filetype quickfix,help,terminal,man nnoremap <buffer><nowait> d <c-d>
            autocmd Filetype quickfix,help,terminal,man nnoremap <buffer><nowait> u <c-u>
            autocmd Filetype quickfix,help,terminal,man nnoremap <buffer><nowait> e <c-e>
            autocmd Filetype quickfix,help,terminal,man nnoremap <buffer><nowait> y <c-y>
        augroup END

    " Basic editor mappings
        " for l:c in ['(', '[', '{']
        "     execute 'inoremap ' . l:c . ';<CR> ' . 
        " endfor
        inoremap (;<CR> (<CR>);<C-o>O
        inoremap (,<CR> (<CR>),<C-o>O
        inoremap (<Space><CR> (<CR>)<C-o>O
        inoremap (<CR> (<CR>

        inoremap {;<CR> {<CR>};<C-o>O
        inoremap {,<CR> {<CR>},<C-o>O
        inoremap {<Space><CR> {<CR>}<C-o>O
        inoremap {<CR> {<CR>

        inoremap [;<CR> [<CR>];<C-o>O
        inoremap [,<CR> [<CR>],<C-o>O
        inoremap [<Space><CR> [<CR>]<C-o>O
        inoremap [<CR> [<CR>

        inoremap )<CR><CR> <c-o>A)<CR>
        inoremap );<CR><CR> <c-o>A);<CR>
        inoremap ),<CR><CR> <c-o>A),<CR>

        inoremap }<CR><CR> <c-o>A}<CR>
        inoremap };<CR><CR> <c-o>A};<CR>
        inoremap },<CR><CR> <c-o>A},<CR>

        inoremap ]<CR><CR> <c-o>A]<CR>
        inoremap ];<CR><CR> <c-o>A];<CR>
        inoremap ],<CR><CR> <c-o>A],<CR>

        " TODO: Map backspace to be <BS><Del> when between any of these pairs
        " of characters and whitespace beyond that (eg \s+'[cursor]'\s+)

        " TODO: Map characters not to auto-close when cursor is on the outside
        " of an enclose (eg ')[cursor]')

        inoremap ;<CR><CR> <c-o>A;<CR>
        inoremap ,<CR><CR> <c-o>A,<CR>

        inoremap <expr> <CR> pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
        " inoremap <expr> ;<CR> pumvisible() ? "\<C-y>;<CR>" : ";\<CR>"

        " TODO: figure out how to do this without remapping escape
        " inoremap <expr> <Esc> pumvisible() ? "\<C-e>\<Esc>" : "\<Esc>"

    " Text-object mappings
        " Line
            " Inner line
            xnoremap <silent> il :<c-u>normal! g_v^<cr>
            onoremap <silent> il :<c-u>normal! g_v^<cr>

            " All line
            xnoremap <silent> al :<c-u>normal! $v0<cr>
            onoremap <silent> al :<c-u>normal! $v0<cr>

            " In indent
            nnoremap <silent> vii :call SelectInnerIndent()<cr>

        " Indent
            function! SelectInnerIndent() abort
                let l:start = FindStartOfIndent()
                let l:end = FindEndOfIndent()

                execute 'normal! ' . l:start . 'GV' . l:end . 'G'
            endfunction

            function! FindEndOfPreviousIndent() abort
                let l:indent = indent('.')

                for l:x in range(line('.') - 1, 1, -1)
                    let l:xindent = indent(l:x)
                    let l:blank = getline(l:x) =~# '^\s*$'

                    if l:xindent < l:indent && !l:blank
                        return l:x
                    endif
                endfor
            endfunction

            function! FindStartOfIndent() abort
                let l:indent = indent('.')

                for l:x in range(line('.') - 1, 1, -1)
                    let l:xindent = indent(l:x)
                    let l:blank = getline(l:x) =~# '^\s*$'

                    if l:xindent < l:indent && !l:blank
                        return l:x + 1
                    endif
                endfor

                return line('.')
            endfunction

            function! FindStartOfIndentContiguous() abort
                let l:indent = indent('.')

                for l:x in range(line('.') - 1, 1, -1)
                    let l:xindent = indent(l:x)
                    let l:blank = getline(l:x) =~# '^\s*$'

                    if l:xindent != l:indent || l:blank
                        return l:x + 1
                    endif
                endfor
            endfunction

            function! FindEndOfIndentContiguous() abort
            endfunction

            function! FindEndOfIndent() abort
                let l:indent = indent('.')

                for l:x in range(line('.') + 1, line('$'))
                    let l:xindent = indent(l:x)
                    let l:blank = getline(l:x) =~# '^\s*$'

                    if l:xindent < l:indent && !l:blank
                        return l:x - 1
                    endif
                endfor

                return line('.')
            endfunction

            function! FindStartOfNextIndent() abort
            endfunction

    " Complex/function mappings
        " TODO: Turn this into a better function so it can just be one mapping
        " nnoremap gs) a<BS><CR>)<ESC>O
        " nnoremap gs] a<BS><CR>]<ESC>O
        " nnoremap gs} a<BS><CR>}<ESC>O
        nnoremap gs :call <SID>SplitBlock()<CR>O

        let s:char_pairs = {
            \ '(':  ')',
            \ '[':  ']',
            \ '{':  '}',
            \ '"':  '"',
            \ "'":  "'",
        \ }

        let s:char_pairs_escaped = {
            \ '(':  ')',
            \ '\[':  '\]',
            \ '{':  '}',
            \ '"':  '"',
            \ "'":  "'",
        \ }

        inoremap <silent><expr> ' MapQuote("'")
        inoremap <silent><expr> " MapQuote('"')
        inoremap <silent><expr> ( MapEnclosure('(')
        inoremap <silent><expr> [ MapEnclosure('[')
        inoremap <silent><expr> { MapEnclosure('{')
        inoremap <silent><expr> ) MapEndEnclosure(')')
        inoremap <silent><expr> ] MapEndEnclosure(']')
        inoremap <silent><expr> } MapEndEnclosure('}')

        inoremap <silent><expr> <BS> MapBackspace()

        function! MapBackspace() abort
            for l:k in keys(s:char_pairs_escaped)
                if search('\m\(\s\|^\)\zs' . l:k . '\%#' . s:char_pairs_escaped[l:k] . '\ze\(\s\|$\)', 'n')
                    return "\<BS>\<Del>"
                endif
            endfor

            return "\<BS>"
        endfunction

        function! MapQuote(char) abort
            let l:left_char = getline('.')[virtcol('.') - 2]
            let l:right_char = getline('.')[virtcol('.') - 1]

            if l:right_char ==# a:char
                return "\<C-G>U\<Right>"
            elseif l:left_char =~# "\\m\\w\\|'\\|\"\\|)\\|]\\|}\\|/\\|\\"
                return a:char
            elseif l:right_char =~# "\\m\\w\\|'\\|\"\\|(\\|[\\|{\\|/\\|\\"
                return a:char
            else
                return a:char . a:char . "\<C-G>U\<Left>"
            endif 
        endfunction

        function! MapEnclosure(char) abort
            let l:left_char = getline('.')[virtcol('.') - 2]
            let l:right_char = getline('.')[virtcol('.') - 1]

            if l:right_char ==# a:char
                return "\<C-G>U\<Right>"
            elseif l:left_char =~# "\\m'\\|\"\\|/\\|\\"
                return a:char
            elseif l:right_char =~# "\\m\\w\\|'\\|\"\\|/\\|\\"
                return a:char
            else
                return a:char . s:char_pairs[a:char] . "\<C-G>U\<Left>"
            endif
        endfunction

        function! MapEndEnclosure(char) abort
            let l:right_char = getline('.')[virtcol('.') - 1]
            
            if l:right_char ==# a:char
                return "\<C-G>U\<Right>"
            else
                return a:char
            endif
        endfunction

    " Plugin mappings
        " ALE
            augroup set_ale_mappings
                autocmd!
                autocmd! Filetype * call SetALEMappings(expand('<amatch>'))
            augroup END

            function! SetALEMappings(filetype) abort
                if exists(':ALEInfo') == 2 && (len(ale#linter#Get(a:filetype)) > 0)
                    " nmap <buffer> <leader>ad <Plug>(ale_detail)
                    " nmap <buffer> <leader>ah <Plug>(ale_hover)
                    nmap <buffer> <leader>aqn <Plug>(ale_next_wrap)
                    nmap <buffer> <leader>aqp <Plug>(ale_previous_wrap)
                    nmap <buffer> <leader>aqf <Plug>(ale_first)
                    nmap <buffer> <leader>aql <Plug>(ale_last)
                endif
            endfunction

        " Coc
            inoremap <silent><expr> <TAB> exists(':CocInfo') == 2 ? 
                \ pumvisible() ? coc#_select_confirm() : "\<TAB>" : "\<TAB>"

            inoremap <silent><expr> <TAB>
                \ exists(':CocInfo') == 2 ? pumvisible() ? coc#_select_confirm()
                \ : coc#expandableOrJumpable() ? "\<C-r>=coc#rpc#request(
                \ 'doKeymap', ['snippets-expand-jump',''])\<CR>" : "\<TAB>" : "\<TAB>"
                
                " coc#refresh() triggers completion
                " <SID>check_back_space() ? "\<TAB>" : coc#refresh() : "\<TAB>"

            function! s:check_back_space() abort
              let l:col = col('.') - 1
              return !l:col || getline('.')[l:col - 1]  =~# '\s'
            endfunction

            augroup set_coc_mappings
                autocmd!
                autocmd! Filetype * call SetCocMappings(expand('<amatch>'))
            augroup END

            function! SetCocMappings(filetype) abort
                if exists(':CocInfo') == 2 && index(s:coc_filetypes, a:filetype, '', v:true) != -1
                    nnoremap <buffer><expr><leader>cs CocActionAsync('showSignatureHelp')
                    nnoremap <buffer><expr><leader>ch CocActionAsync('doHover')

                    nmap <buffer><leader>ca v<Plug>(coc-codeaction-selected)
                    xmap <buffer><leader>ca <Plug>(coc-codeaction-selected)

                    nmap <buffer><leader>crn <Plug>(coc-rename)

                    nmap <buffer><leader>cqi <Plug>(coc-diagnostic-info)
                    nmap <buffer><leader>cqn <Plug>(coc-diagnostic-next)
                    nmap <buffer><leader>cqp <Plug>(coc-diagnostic-prev)
                endif
            endfunction

        " EasyAlign
            augroup set_easyalign_mappings
                autocmd!
                autocmd VimEnter * call SetEasyAlignMappings()
            augroup END

            function! SetEasyAlignMappings() abort
                if exists(':EasyAlign') == 2
                    nmap <leader>ea <Plug>(EasyAlign)
                    xmap <leader>ea <Plug>(EasyAlign)
                    " xmap <CR> <Plug>(EasyAlign)
                    nmap <leader>el <Plug>(LiveEasyAlign)
                    xmap <leader>el <Plug>(LiveEasyAlign)
                endif
            endfunction

        " Flutter
            augroup set_flutter_mappings
                autocmd!
                autocmd Filetype * call SetFlutterMappings(expand('<amatch>'))
            augroup END

            function! SetFlutterMappings(filetype) abort
                if exists(':FlutterRun') == 2 && index(s:flutter_filetypes, a:filetype, '', v:true) != -1
                    nnoremap <buffer><leader>frl :FlutterHotReload
                    nnoremap <buffer><leader>frs :FlutterHotRestart
                    nnoremap <buffer><leader>fvd :FlutterVisualDebug
                endif
            endfunction

        " Surround
            " TODO: turn S into an operator. In normal mode, I want to do 
            " "Siw'" instead of "viwS'". See :h map-operator

    " TODO: set these remaps:
        " tab and s-tab to move up and down completion menu
        " backspace to close menu if an entry is selected? backspace otherwise
        " space to accept if an entry is selected, space otherwise?
        " enter to accept and jump if an entry is selected, enter otherwise
        " figure out snippets

" Custom functions
    let s:block_pairs = {
        \ '(':    ')',
        \ ')':    ')',
        \ '[':    ']',
        \ ']':    ']',
        \ '{':    '}',
        \ '}':    '}',
    \ }

    function! s:GetCursorChar()
        let l:col = virtcol('.') - 1
        let l:char = strcharpart(getline('.'), l:col, 1)
        return l:char
    endfunction

    " TODO: improve the s:SplitBlock function
    function! s:SplitBlock() abort
        let l:char = s:GetCursorChar()

        if l:char =~? '(\|[\|{'
            execute "normal! la\<BS>\<CR>" . s:block_pairs[l:char]
        elseif l:char =~? ')\|]\|}'
            execute "normal! a\<BS>\<CR>" . s:block_pairs[l:char]
        endif
    endfunction

" augroups
    augroup statusline_update
        autocmd!
        autocmd TextChanged,CompleteChanged,CursorHold * let &l:statusline = &l:statusline
    augroup END

    " window appearance
        augroup nowrite_file_appearance
            autocmd!
            autocmd Filetype help,qf,man,startify setlocal nonumber
            autocmd Filetype help,qf,man,startify setlocal nolist
        augroup END

    augroup SetStatusLines
        autocmd!
        " call Filetype,SessionLoadPost,CursorMoved,BufUnload
        " autocmd TerminalOpen,BufWinEnter,BufEnter,WinEnter,Filetype * call SetStatusLineActive()
        " autocmd Filetype netrw call SetStatusLineActive()
        " autocmd BufLeave,WinLeave * call SetStatusLineInactive()
    augroup END

    augroup SetTabLines
        autocmd!
        " autocmd VimEnter,BufEnter,BufWinEnter,WinEnter,WinNew * call SetTabLine()
        " autocmd WinLeave,BufLeave * call SetTabLine()
    augroup END

    augroup SetNumberColumns
        autocmd!
        " autocmd BufEnter,VimEnter,WinEnter * call SetNumberColumnActive()
        " autocmd WinLeave * call SetNumberColumnInactive()
    augroup END

    augroup SetListChars
        autocmd!
        " autocmd InsertEnter * set listchars=tab:«-»,extends:›,precedes:‹,nbsp:∅
        " autocmd InsertLeave * set listchars=tab:«-»,trail:∙,extends:›,precedes:‹,nbsp:∅
        " autocmd OptionSet listchars,virtualedit call
                    " \ EchoOptionSet('<amatch>', 'v:option_old', 'v:option_new')
    augroup END

    " TODO: add state() to the statusline

    if isdirectory(expand('~/.dotfiles'))
        source ~/.dotfiles/mvimfiles/highlight.vim
        " TODO: set colorscheme minimalist
            " change red (statement?) to 204
            " change background to 235
            " change yellow to 214
        source ~/.dotfiles/mvimfiles/status.vim
        source ~/.dotfiles/mvimfiles/foldtext.vim
        source ~/.dotfiles/mvimfiles/tab.vim

        set foldtext=GetFoldText()
        set tabline=%!SetTabLine()
    endif

    " augroup virtualedit
    "     autocmd!
        " autocmd InsertEnter * echo v:insertmode
        " autocmd CursorMovedI * echo ''
        " autocmd InsertLeave * echo v:insertmode
        " autocmd InsertEnter * call SetVirtualEdit(v:insertmode)
        " autocmd InsertLeave * call UnsetVirtualEdit(v:insertmode)
        " autocmd CursorMoved,CursorMovedI,CursorHold,CursorHoldI,TextChanged,TextChangedI,TextChangedP * echo mode(1)
    " augroup END

    " function! SetVirtualEdit(mode) abort
    "     let b:normal_list = &l:list
    "     let b:normal_listchars = &l:listchars
    "     if a:mode =~# 'r\|v'
    "         setlocal list
    "         setlocal listchars=tab:«-»,space:∙,trail:∙,extends:›,precedes:‹,nbsp:∅,conceal:∙
    "     endif
    " endfunction

    " function! UnsetVirtualEdit(mode) abort
    "     if a:mode =~# 'r\|v'
    "         let &l:list = b:normal_list
    "         let &listchars = b:normal_listchars
    "     endif
    " endfunction

    " function! StatuslineThing() abort
    "     if mode(1) ==# "\<c-v>"
    "         set listchars=tab:«-»,space:∙,trail:∙,extends:›,precedes:‹,nbsp:∅,conceal:∙
    "     endif
    "     return '%f %c %l'
    " endfunction

    " augroup SetForVirtualReplace
    "     autocmd!
        " autocmd InsertEnter * call SetModeChanges(v:insertmode)
        " autocmd InsertChange * call SetModeChanges(v:insertmode)
        " autocmd InsertLeave * call UnsetModeChanges()
    " augroup END

    " augroup SetForVirtualEdit
    "     autocmd!
    "     autocmd OptionSet * call SetList(expand('<amatch>'))
    " augroup END

    " augroup ManPage
    "     autocmd!
    "     autocmd Filetype man set keywordprg=:Man
    " augroup END

    " augroup ListOption
    "     autocmd!
        " autocmd &buftype nofile,quickfix,help,terminal,prompt,popup setlocal nolist
        " autocmd &buftype help echo 'Hello'
        " autocmd Filetype help,quickfix,terminal,prompt setlocal nolist
        " autocmd TerminalOpen,BufWinEnter,BufEnter,WinEnter,Filetype * call SetListOption()
    " augroup END

    " function! SetListOption() abort
    "     if &buftype =~# 'nofile\|quickfix\|help\|terminal\|prompt\|popup'
    "         echomsg 'Hello it worked this time'
    "     endif
    " endfunction

    " fun! EchoOptionSet(name, old, new) abort
    "     let l:msg = 'ATTN: Option ' . a:name
    "     let l:msg.= ' has been reset from: ' . a:old
    "     let l:msg.= ' to: ' . a:new
    "     echomsg l:msg
    " endfun

    " fun! SetListCharsVisual() abort
    "     if mode(1) ==#
    " endfun

    " function! SetModeChanges(mode)
    "     if a:mode ==# 'v'
    "         setlocal list
    "     elseif a:mode =~# 'i\|r'
    "         setlocal nolist
    "     endif
    " endfunction

    " function! UnsetModeChanges()
    "     setlocal nolist
    " endfunction

    " function! SetList(option)
    "     if a:option ==# 'virtualedit'
    "         echo 'it worked'
    "     endif
    " endfunction

" TODO
    " augroup to set virtualedit when in virtual-replace mode? Maybe also set
    " invisible characters to be seen
        " reference set list, listchars

" Ideas
    " Add something which shows invisible characters when you enter virtual-
        " edit mode or whatever
    " Add logic to only set plugin settings when the plugin is present? So when
        " I toggle them off they don't get set
    " Fix the git branch thing
    " Add shortmess settings
    " Add something to deal with "DIR" when the file is new or a terminal or
        " anything else
    " Add sessions settings
    " Add vim-plug automatic installation
    " Deal with statusline not updating if the cursor doesn't move
    " autocmd to clear matchparen when leaving a window
    " autocmd to remove trail from listchars in insert mode
    " g:netrw_dirhistmax

